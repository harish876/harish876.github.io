---
+++
author = "Harish Krishnakumar"
title = "The Go, HTMX, and a CLI Tale: Building Web Apps the Hard Way (and Loving It!) ✨"
date = "2024-07-29"
description = "In this installment of Tools, Terminal and TCP, I'm sharing the story of Hypefx – my journey building a Go + HTMX web framework from scratch, taming routes with Tree-Sitter, and pushing back against frontend bloat."
+++

In this installment of Tools, Terminal and TCP, I want to tell you about a project that was truly a *first* for me: building a developer tool of this magnitude, from the ground up. It’s a project born out of a little frustration, a lot of curiosity, and an even bigger desire to see what happens if we build web apps a different way. I call it [Hypefx](https://github.com/harish876/hypefx).

### The Great JS Escape (and why Go and HTMX clicked)

You know that feeling? The one where you're just... *tired* of writing JavaScript? Yeah, I was there. I found myself increasingly frustrated with the sheer bloat of modern frontend frameworks. It felt like even the simplest "hello world" required a small village of dependencies, build tools, and a PhD in `node_modules` archeology.

I remember this one time, I was debugging a seemingly simple Vite + Shadcn template. I fired up the dev server, opened the network tab, and bam! It was loading *all* the Tabler icons on every single page reload. All of them! Even if I only used one icon! That’s when it hit me: modern web development, while offering incredible power, often hides so much complexity behind layers of abstraction that you barely know what’s going on under the hood. It felt like we were just blindly accepting the status quo.

And that, my friends, is not how Harish operates. I love understanding how things work. I love building things from scratch, even if it’s the "hard way," just for the sheer joy of it. So, I started asking: what if we could unpack this? What if we could build a web app with the power of a compiled language, the simplicity of HTML, and without the endless JavaScript merry-go-round?

Enter Go and HTMX.

When I stumbled upon HTMX, it felt like a breath of fresh air. "Complete HTML as a hypertext!" – that resonated deeply. It's about letting HTML do what it does best, extended just enough to be dynamic without needing an entire client-side framework. And Go? Well, Go is just a magnificent language. Its simplicity, concurrency primitives, and raw speed make it a joy to build with. Then there was Templ, a JSX-like templating language for Go. It was love at first sight. Imagine designing your UI components in Go, getting compile-time checks, and spitting out pure HTML. Sweeet!

So, the idea for Hypefx was born: a framework to build simple SPAs using Go and HTMX, with Templ for the UI. My goal wasn't to replace the giants, but to offer a different take, a simpler, faster path for curious engineers like you and me.

### Early Steps: From Idea to CLI

The first thing I realized was, even with Go and HTMX, there's still a bit of boilerplate to set up a new project: `go mod init`, Tailwind CSS configuration, `main.go` for the Echo server, etc. And you know me, grug hate boilerplate! (Okay, *Harish* hates boilerplate.) This was the perfect candidate for a CLI tool.

So, `hypefx` got its CLI. My first mission: a `generate` command.

```bash
go install github.com/harish876/hypefx@latest
hypefx generate my-awesome-app
```

This command kicks off a whole chain of events: it scaffolds out a project structure, sets up your `cmd/main.go`, adds `input.css` for Tailwind, and even gives you a `package.json` with dev scripts.

The `Makefile` inside the generated project also becomes your best friend:

```makefile
dev/server:
	air -c air.toml

dev/tailwind:
	npm install && npx tailwindcss -i ./input.css -o ./assets/css/styles.css --watch

dev:
	hypefx build routes && make -j2 dev/tailwind dev/server
```
Just `make dev` and you're off to the races! It handles Templ compilation, Tailwind watching, and spinning up your Go server with `air` for hot reloading. It’s like a little orchestra, all playing in harmony.

### Taming the Wild West of Routes (with a sprinkle of magic)

One of the features I was super keen on was file-based routing. I love the simplicity of creating a file and having it magically become a route. No more massive routing files where you register every single handler manually. But how do you *automagically* turn a Go file's function into an HTTP route? This was a fun challenge.

My approach involved a little bit of parsing and a lot of pattern matching. I wanted to use annotations directly in the Go code. Something like this:

```go
package app

import (
	"net/http"
	"github.com/harish876/hypefx/internal/cli/commands/generate/scaffolding/views/welcome"
	"github.com/labstack/echo/v4"
)

// @get /
func WelcomeHandler(c echo.Context) error {
	return Render(c, http.StatusOK, welcome.Welcome())
}

// @post /submit-form
func SubmitFormHandler(c echo.Context) error {
    // ... handle form submission
    return c.String(http.StatusOK, "Form submitted!")
}
```

See those `// @get /` and `// @post /submit-form` comments? That's where the magic happens. I needed a way to read these comments, extract the HTTP method and path, and then generate the `routes.RegisterRoutes` function that Echo could use.

This is where my old friend, [Tree-Sitter](https://tree-sitter.github.io/tree-sitter/), made a grand entrance. If you've been following my "Tools, Terminal and TCP" series, you know I have a soft spot for it. Tree-Sitter is a parser generator that builds an Abstract Syntax Tree (AST) of your code. Instead of line-by-line regex hacks (which, let's be honest, would have been an abject failure), Tree-Sitter gives you a structured representation of your code.

I wrote some Tree-Sitter queries specific to Go to find these "annotation comments" and then locate the function definition right below them. This way, I could reliably map a comment to a function, extract the necessary information, and then programmatically generate the `routes.go` file.

The `hypefx build routes` command is what makes this happen:

```bash
hypefx build routes
```

This command scans your `app` directory, finds all your annotated handlers, and generates a `routes.go` file that looks something like this (simplified):

```go
// routes.go - AUTO-GENERATED, DO NOT EDIT
package routes

import (
	"github.com/labstack/echo/v4"
	"github.com/my-module/app" // Your app package
)

func RegisterRoutes(e *echo.Echo) {
    e.GET("/", app.WelcomeHandler)
    e.POST("/submit-form", app.SubmitFormHandler)
    // ... more routes
}
```

This automates a huge chunk of manual work! The only sucky part, for now, is that you still have to manually add `routes.RegisterRoutes(app)` to your `cmd/main.go` after `app.Static("/", "assets")`. But don't worry, my future plans definitely include automating this step. One step at a time, right?

### Building Blocks: My Little Component Library

Beyond routing, I wanted to provide some common UI components built with Templ, making it easy to drop in form inputs, dropdowns, and even a basic data grid without reaching for heavy JavaScript libraries. Think of them as headless UI components, ready for you to style with Tailwind.

For instance, an input component looks pretty clean:

```go
package input

// ... (InputProps definition)

templ Input(props InputProps) {
	<label for={ props.Id } class="text-sm font-medium text-gray-700 flex gap-2">
		{ props.Label }
	</label>
	// ... (input element with conditional attributes based on props)
}
```

I'm semi-proud of these components, especially the `grid` one. Building a configurable, reusable data grid entirely in Go and Templ, powered by HTMX, was a solid challenge. It required a lot of thought around how data types, filtering, and editing would work across the wire with minimal JS.

### Challenges, Learnings, and Future Shenanigans

Building Hypefx has been an incredible journey. It's not without its quirks, though. One area that's been a little tricky is module imports and code generation. When you're generating code that references other parts of the user's Go module, you have to be super careful with import paths. It's one of those things that seems simple but can quickly become a "clusterfuck of me not knowing git at all" kind of moment (yes, that's a real commit message from my history, lol). It's all part of the learning process!

Looking at the commit history, you'll see a lot of "improving cmd/main.go file and squashing bugs," "revmaped config," and "revamp tests." It's an iterative process, constantly refining, simplifying, and adding those little quality-of-life features like CLI autocompletion.

This project is very much a Work In Progress, but I have so much more planned! I want to truly bake file-based routing into the dev server, removing some of these separate `build` commands and integrating them into one seamless experience. And of course, more "batteries included" for common web app utilities.

My main message through this project is simple: Go is a fantastic language, and we don't always need massive JavaScript frameworks to build fast, responsive web applications. There's immense joy in understanding the layers, breaking things down, and building tailored solutions from scratch. This is my humble attempt at doing just that.

Hope you found this article engaging and exciting. If you liked it please do give some clappies, star the GitHub repo be a friend, and tell a friend, until then see you in the next installation of "Tools, Terminal and TCP".

<br/>
GitHub Link: [Hypefx](https://github.com/harish876/hypefx)
---