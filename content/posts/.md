+++
author = "Harish Krishnakumar"
title = "Hypefx: Because Life's Too Short for JavaScript Framework Bloat"
date = "2024-07-25"
description = "In this installment of Tools, Terminal and TCP, I spill the beans on my latest obsession: building fast, delightful SPAs with Go and HTMX using Hypefx, my very own little framework. We'll dive into why I ditched the JS-heavy world, how file-based routing became a thing, and why Go truly is God's language."
+++

In this installment of Tools, Terminal and TCP, let's talk about something that's been cooking in my head for a while, something that pulled me deep into the weeds of Go, HTMX, and building tools *the hard way*. I'm talking about [Hypefx](https://github.com/harish876/hypefx) – my answer to the endless cycle of JavaScript framework fatigue and the sheer joy of writing a web app with *zero* client-side JavaScript, unless I *really* want to.

For a long, long time, I'd been building web apps, and let me tell you, the typical development experience felt… heavy. Like, *really* heavy. You'd spin up a project, pull in a bazillion dependencies, configure bundlers, transpilers, dev servers, then spend an eternity debugging some obscure `node_modules` issue just to get a "Hello World" page rendering. And don't even get me started on trying to build a simple todo list that ends up requiring gigabytes of disk space and a build process that makes a NASA rocket launch look trivial. **JSON as a communication protocol between client and server? Crazy!** There has to be a better way, right?

That's when I stumbled upon HTMX. And let me tell you, it was like finding an oasis in the desert. The idea of backend-driven UI, where HTML is the primary communication mechanism, just clicked. No more complex client-side state management, no more wrestling with hydration issues, just good old HTML flowing directly from the server. And if you're going to render HTML on the server, what better language to do it with than Go? **Go is God's language**, after all. Its simplicity, performance, and concurrency primitives are just *chef's kiss* for web servers.

### The Go + HTMX + Templ Story

So, I had my ingredients: Go for the backend, HTMX for the sprinkle of interactivity. But what about the UI? I'd tried Go's native `html/template`, but it felt a bit… verbose, and frankly, I missed the component-driven development style I was used to from the JS world (minus the JS, obviously). That's when `Templ` by Adrian Hesketh entered the chat. Templ is this fantastic Go templating language that compiles directly to Go code. It feels so much like JSX, but you write your UI components directly in Go. Type-safe, fast, and pure Go. It was love at first sight.

With this trifecta – Go, HTMX, and Templ – I saw a path to building fast, simple, and maintainable web applications without all the traditional frontend baggage. But, as always, setting up a new project from scratch, even with these wonderful tools, involves a bit of boilerplate, some common patterns, and a dev loop that needs to be just *right*. And that, my friends, is how `hypefx` was born.

### Enter `hypefx`: My "Grug Love Tool" for the Web

You know how Grug loves tools, right? Tools that make life easier, tools that do the repetitive, mind-numbing stuff so Grug can focus on the fun, challenging bits. Well, `hypefx` is my "Grug Love Tool" for building web apps in Go. I wanted a CLI that could:

1.  **Scaffold a project:** Get me from zero to a running Go + HTMX + Tailwind app in seconds.
2.  **Handle routing magic:** Because manually registering every route feels like a chore from the dark ages.
3.  **Generate static bits:** For those parts of the site that don't need to be dynamic.
4.  **Give me some batteries:** Common UI components built with Templ, ready to plug and play.

Here's how you get `hypefx` into your toolkit:

```sh
go install github.com/harish876/hypefx # for the release build
go install --build=test github.com/harish876/hypefx # if you're feeling adventurous and want the latest test build
```
And a quick check to make sure it's all there:
```sh
hypefx --version
```

### Building the CLI: No More Boilerplate Blues

The `generate` command was one of the first things I tackled. I mean, who wants to manually set up `tailwind.config.js`, `input.css`, `cmd/main.go`, and all the basic `views` directories every single time? Not me. I wanted to just type:

```sh
hypefx generate my-awesome-app
```

And BAM! A fully set up project, ready to go. This command kicks off a few things:
*   It creates a new directory for your project.
*   It copies over a pre-defined scaffolding (the `internal/cli/commands/generate/scaffolding` directory holds all this goodness).
*   It sets up a basic `cmd/main.go`, `app` directory for handlers, and `views` for your Templ components.
*   It even tells you what `go mod init` and `go mod tidy` to run.

It’s like an instant espresso shot for your web project.

### File-Based Routing: A Little Magic Under the Hood

This was a particularly fun challenge. I've always loved file-based routing in other frameworks – the idea that your file structure dictates your URL paths just makes so much sense. So, I thought, "let's see what happens if I try to build that for Go and HTMX."

My goal was simple: place a Go file with an `@get`, `@post`, `@put`, or `@delete` annotation in its function comment, and `hypefx` should automatically figure out the route and register it with `Echo`. No more manually writing `app.GET("/users", handlers.GetUsers)`. We're going full auto here!

So, how did I make this magic happen? It involves a bit of static analysis, peeking into your Go files. We read your Go files, parse them (not with regex, because regex is for sadists and simple cases!), and look for those specific annotations. Then, we use that information to generate a `routes.go` file.

Here's a glimpse into the `cmd/main.go` snippet after you run `hypefx generate` and `hypefx build routes`:

```go
package main

import (
	"github.com/labstack/echo/v4"
    "my-awesome-app/routes" // This path would be specific to your module
)

func main() {
	app := echo.New()
	app.Static("/", "assets")

    // The magic happens here!
    routes.RegisterRoutes(app) // hypefx generates this for you!

    app.Logger.Fatal(app.Start(":42070"))
}
```
And what does `hypefx build routes` do? It scans your `app` directory, finds your handlers, extracts the route information using those annotations (like `@get`), and then *generates* that `routes.RegisterRoutes(app)` function for you. It's like having a little code-generating elf living in your terminal.

```sh
hypefx build routes
```

This command goes through your project, finds all the `*.go` files that define handlers, parses their ASTs (Abstract Syntax Trees, if you're curious!), and collects all the `@get`, `@post`, etc., annotations. It then generates the `routes.go` file with all the `app.METHOD("/path", handler)` calls in one neat `RegisterRoutes` function. This was one of the most satisfying parts to build because it automates a core piece of web development.

### Little Batteries Included: UI Components and More

Beyond the scaffolding and routing, I wanted `hypefx` to offer some readily available UI components. Not a full-blown component library that tries to do everything, but rather a lightweight, *headless* set of common elements built entirely with Templ. We've got stuff like:

*   **Inputs:** Basic text inputs, numbers, passwords, with validation hints.
*   **Dropdowns:** Single and multi-selects, because those are always a pain to get right with just HTML/CSS/HTMX.
*   **Grids:** A highly customizable data grid component (`components/grid/grid.templ`) that knows how to interact with a backend API for pagination, filtering, and editing. This one is quite beefy and proud of it!
*   **Notifications:** Simple toast messages that pop up based on HTMX responses.

The idea here is not to lock you into a specific style but to provide the *functionality* in Go/Templ so you can style it with Tailwind (which is included in the boilerplate) however you like. Think of it as a starter pack of common UI patterns, allowing you to focus on your unique application logic.

### What's Next? (Because a Hacker's Work is Never Done)

This project, `Hypefx`, is very much a Work-In-Progress, a hacker's notebook brought to life. There are a few manual steps, like needing to add `routes.RegisterRoutes(app)` to your `cmd/main.go`, which I'm actively looking to automate. My vision is to streamline the dev server experience, making `hypefx` the single command you need to run to get everything hot-reloading and working seamlessly.

I'm also keen on baking more common utilities directly into `hypefx` – things I find myself reaching for in almost every web project. The goal is to make `hypefx` a robust yet opinionated framework that simplifies building high-performance SPAs with Go and HTMX, allowing developers to move fast and focus on what truly matters: solving real-world problems.

Hope you found this article engaging and exciting. Building `hypefx` from scratch has been a truly groundbreaking experience for me, cementing my love for Go and the elegant simplicity of HTMX. It’s a testament to how powerful it can be to build your own tools when the existing ones feel like overkill or don’t quite fit your vision.

If you liked it, please do give some clappies, star the GitHub repo be a friend, and tell a friend. Until then, see you in the next installation of "Tools, Terminal and TCP"!

GitHub Link: [Hypefx](https://github.com/harish876/hypefx)
+++